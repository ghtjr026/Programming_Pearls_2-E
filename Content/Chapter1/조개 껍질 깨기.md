1장 조개 껍질 깨기

a. 대화

- 대화를 통해 정확한 문제 파악

b. 정확한 문제 기술

- 파악된 문제를 유용한 형태로 정리

e.g)

디스크 파일을 어떻게 정렬 하는가?

입력 : 최대 n개의 양의 정수를 포함하는 파일로, 각 숫자는 n보다 작고, n = 10^7이다. 어떤 숫자가 두 번 이상 나오는 것은 치명적 에러이다. 정수 이외에 관련된 데이터는 없다

출력 : 입력된 정수를 오름차순으로 정렬한 리스트

제약조건: 메모리를 많아야 대략 1MB 정도를 사용할 수 있고 디스크 공간은 충분하다. 실행시간은 최대 몇 분 정도가 될 수 있고, 10초 정보 안에 작업을 끝낼 수 있으면 충분하다.

c. 프로그램 디자인

- 머지 정렬 프로그램은 입력 파일을 한번 읽어 들인 다음, 작업 파일을 여러 번 읽고 쓰는 과정을 통해 정렬을 하고, 결과를 한 번에 저장한다.

 

40-패스 알고리즘은 입력 파일을 여러 번 읽지만, 출력은 단, 한 번만 저장하고, 중간 파일도 사용하지 않는다.

 

위 두 방법의 장점을 조합한 방법

입력 파일을 한 번만 읽고, 중간 파일도 사용하지 않는다

입력 파일 안에 있는 모든 숫자를 사용 가능한 메모리 내에 나타낼 수 있어야 가능하다.

-> 문제를 정수를 비트에 표현할 수 있느냐로 압축된다.

 

d. 구현 스케치

비트맵 또는 비트 벡터 표현법을 사용할 수 있다.

//1단계 : 모든 비트를 0으로 초기화

for I = [0. n]

bit[i] = 0

//2단계 : 존재하는 숫자를 비트맵에 표시

for each I in the input file

bit[i] = 1

//3단계 : 정렬된 결과를 기록

for I = [0, n]

if bit[i] == 1

write I on the output file

for I [0, n] : I를 0부터 n-1까지 반복하는 것을 의미

 

e. 원리

- 정확한 문제 정의

- 비트맵 데이터 구조

-> 비트맵 데이터 구조는 원소가 중복되지 않고 원소와 관련된 다른 데이터도 없는 촘촘한 유한 집합을 표현한다.

- 다중 패스 알고리즘

-> 입력 파일을 여러 번 읽어 각 단계마다 조금씩 작업한다.

- 시간-공간 트레이드오프인 것과 아닌 것

-> 프로그램이 시간을 더 사용하면 공간을 덜 사용할 수 있다는 것이다.

-> 프로그램이 사용하는 공간을 줄이면 그 실행시간 역시 줄어드는 경우도 있다.

-> 공간을 효율적으로 사용하는 비트맵 구조는 정렬 시간을 크게 단축시켰다.

-> 데이터가 적다는 것은 처리하는 시간도 적다는 것을 의미, 데이터를 디스크보다는 메모리에 두면 디스크에 접근하는 오버헤드를 피할 수 있다.

- 단순한 디자인

-> 보통 간단한 프로그램이 복잡한 프로그램보다 더 신뢰할 수 있고, 안전하고, 견고하고, 효율적이며 빌드와 유지보수를 하기 쉽다.