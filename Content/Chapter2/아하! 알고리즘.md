2장 아하! 알고리즘

a. 세 가지 문제

1. 최대 40억 개의 32비트 정수가 랜덤한 순서로 들어와 있는 순차적 파일이 주어졌다. 이때 이 파일에 포함되지 않은 임의의 32비트 정수 하나를 찾아라. 메모리를 넉넉히 쓸 수 있다면 이 문제를 어떻게 풀겠는가? 메모리는 수백 바이트밖에 없고, 너댓 개의 외부 임시 파일을 사용할 수 있는 상황이라면 어떻게 해결할 수 있을까?

 

2. n개의 원소를 가지는 1차원 벡터를 I만큼 왼쪽으로 회전시켜라. 예를 들어 n=8, I=3 일 경우 abcdefgh 라는 벡터를 회전시키면 defghabc가 된다. 간단한 코드로는 n개의 원소를 가지는 임시 멕터를 사용하여 n번의 단계를 통해 해결할 수 있다 여분의 메모리가 수십 바이트 밖에 안 되는 상황에서도 n에 비례하는 시간 내에 벡터를 회전시킬 수 있겠는가

 

3. 주어진 영단어 사전에서 전철어구(anagram)의 집합을 모두 찾아내라. 예를 들어 “pots”, “stop”, “tops”는 철자의 순서만 바꾸면 만들어지므로 서로 전철어구이다.

 

b. 여기저기에서 쓰이는 이진 탐색

 

c. 기초적인 조작의 위력

문제 2 는 n개의 원소를 가지는 벡터 x를 I만큼 왼쪽으로 회전시키고자 하는 것이다.

해결 방법

1. 저글링 조작

-> x[0]를 임시 저장소인 t로 옮긴 후 x[i]를 x[0]으로, x[2i]를 x[i]로 옮기는 식의 조작을 뜻함.

2. 벡터 ab의 두 부분을 맞바꾸어 벡터 ba로 만드는 것 (a는 x의 처음 I개의 원소를 나타냄)

-> a와 b부분을 각각 reverse 시킨 후 x를 reverse 시킴으로 ab -> ba로 만듦.

 

d. 정렬

문제 3 는 영어단어 사전이 주어져 있고, 그중에서 모든 전철어구의 집합을 찾아내야 한다.

해결 방법

1. 단어에 일정한 표시를 하여, 그 표시가 전철어구끼리는 같게 만든다.

-> 알파벳 순으로 정렬(수평)하고, 같은 알파벳을 묶는다(수직 정렬).

-> 예 : “pots” -> “o1p1s1t1”, “stop” -> “o1p1s1t1” => 전철어구

 

e. 원리

- 정렬

-> 정렬을 사용하는 것은 당연히 정렬된 출력을 위한 것으로, 시스템의 명세 일 수도 있지만 다른 프로그램을 위한 준비 단계일 수도 있다.

- 이진 탐색

-> 정렬된 집합에서 원하는 원소를 찾아내는 알고리즘으로, 효율적이고, 메모리나 디스크상에서 사용될 수 있다.

- 표시

-> 하나의 동치 관계가 집합을 정의하는 경우, 그 집합에 포함되는 모든 원소가 같은 표시를 가지도록 정의하는 것이 도움이 된다.

- 문제 해결자의 관점

-> 처음의 아이디어를 바로 적용하려고 달려들기보다는 문제를 좀 더 깊게 분석하여 어떤 영감을 얻으려고 한다. 분석만 하고 있으면, 안되고 적당한 때에 구현을 시작할 수 있는 균형이 필요하다.